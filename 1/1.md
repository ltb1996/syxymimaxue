第 1 章　引言
本章内容：
● 密码学的定义；
● 理论密码学与实用密码学之间的区别；
● 本书包含的密码学知识。
你好，旅行者！
请扶好坐稳，我们将进入一个充满奇迹和弥漫着神秘色彩的密码学世界。密码学是一门古老的科学，用于保护易受到恶意用户侵扰的场景。本书将带领读者使用「咒语」来抵御恶意攻击。许多人曾经尝试学习密码学这门科学，但很少有人能经受得住学习之路上面临的挑战，难以真正掌握这门科学。激动人心的冒险旅途在前面等待着我们！
本书将揭示密码算法如何保证我们的信件安全，帮助我们识别「盟友」，保护信息免遭他人窃取。密码学是现实世界中所有安全技术的基础，密码学上的一丁点儿错误都可能带来难以估量的损失，因此探索密码学的旅途注定不会一帆风顺。
记住：
即便发现自己在密码学的海洋里迷失了方向，我们也仍要继续向前航行。请相信，我们终会冲破迷雾，见到光明。
++1.1　密码学使协议安全
在本次密码学旅行的开始，先向读者介绍密码学的目标：密码学是一门旨在保护协议免受攻击者破坏的科学。那么，协议是什么呢？简单来说，协议是一个人（或者多个人）为了完成某件事情而必须遵循的一系列步骤。想象这样一个情景：旅途疲惫的我们需要小憩一下，不过这样一来我们的「魔剑」可能在数小时内无人看管。这样一个协议的执行过程可能如下：
（1）把武器放在地上；
（2）在树下小睡一会儿；
（3）从地上捡起武器。
当然，在我们睡着的时候任何人都可能偷走我们的「魔剑」，所以这并不是一个好的协议。在密码学中，我们总会把寻找协议破绽的「敌手」考虑进来。
在古代，当统治者和将军们互相背叛并各自策划秘密行动时，他们面临的最大问题就是如何与他们信任的人分享机密信息。在此背景下，密码学的相关概念和技术应运而生。此后，经过几个世纪的演变，密码学成为一门严谨的科学。如今，密码学无处不在，它为我们提供了许多底层服务，让我们能够从容应对这个复杂多变的世界。
本书的内容与密码学的实践应用密切相关。本书涵盖当今广泛使用的各种密码协议，同时还会展示这些密码协议的组成部分，以及这些协议如何有机地组合在一起。大部分的密码学图书都从密码学的发展开始讲，并介绍它的发展历史，但是我认为这样做没有多大意义，我想介绍一些更加实用的东西。我曾以软件顾问的身份为大公司审查与密码相关的应用程序，也曾作为密码工程师将加密技术应用到各个领域。这些在现实中遇到的密码学知识才是我想分享的。
本书不会涉及令人害怕的数学公式。本书的目的是揭开密码学的神秘面纱，介绍当今常用的密码学技术，并给出这些技术在我们身边的应用案例。本书适合那些对密码学怀有好奇心的人、有强烈求知欲的工程师、富有冒险精神的软件开发人员和兴趣广泛的研究人员。
本章旨在带领读者开启密码学世界之旅。我们将探讨不同类型的密码算法，并找到其中对我们很重要的一部分算法，以及阐明全世界一致使用这些算法的原因。
++1.2　对称密码：对称加密概述
对称加密（Symmetric Encryption）是密码学的重要概念之一。对称密码在密码学中有着举足轻重的地位，本书中的大多数密码算法或协议都用到对称密码。现在，我们借助将要介绍的第一个协议引入对称加密这个新概念。想象这样一个情景：Alice 需要给住在城堡外的 Bob 寄送一封信件。如图 1.1 所示，Alice 要求她忠实的信使（Messenger）骑上他的骏马，穿越前方危险的土地，向 Bob 传递重要消息。然而，Alice 对信使很是怀疑；尽管这位忠实的信使为她效劳多年，但她仍希望此次传递的消息对包括信使在内的所有被动观察者均保密。试想一下，这封信可能包含一些关于王国的流言蜚语。
图 1.1　Alice 通过信使向 Bob 发送重要消息
Alice 需要的是一个协议，它能模拟 Alice 亲自将消息传递给 Bob 的过程。这是一个在现实中不可能解决的问题，除非我们采用密码学（或隐形传输）技术。这就要用到密码学家多年前发明的一种新型加密算法，常称为对称加密算法（Symmetric Encryption Algorithm）。
注意：
顺便说一下，密码学算法通常也被称为密码学原语。我们可以将密码学原语视为密码学中一种最小的算法构造，它通常与其他原语一起用于构造新的协议。「密码学原语」一词经常出现在相关文献中，了解它有利于阅读文献，但它本身确实没有特别的意义，仅仅是一个新的术语而已。
接下来，让我们看看如何使用这个对称加密算法向信使隐藏 Alice 的真实消息。现在，假设这个密码学原语是一个提供了以下两个函数的黑盒子（我们无法看到它的内部构造）。
● ENCRYPT；
● DECRYPT。
第一个函数 ENCRYPT 以密钥（Secret Key）和消息（Message）为输入，它输出一系列看起来像是随机选择的数字，如果我们愿意的话，它也可以输出像噪声一样的数据。我们把这个函数的输出称为加密消息。函数 ENCRYPT 的原理如图 1.2 所示。
图 1.2　函数 ENCRYPT 以密钥和消息为输入，输出一个加密后的消息（看起来像噪声一样的随机数字序列）
第二个函数 DECRYPT 是第一个函数 ENCRYPT 的逆函数，它以 ENCRYPT 输入的密钥和输出的加密消息为输入，输出原始消息。函数 DECRYPT 的原理如图 1.3 所示。
图 1.3　函数 DECRYPT 以密钥和加密消息为输入，输出原始消息
为了使用这个新的密码学原语，Alice 和 Bob 不得不在现实世界中先会面一次，商定他们将要使用的密钥。之后，Alice 可以使用商定的密钥和函数 ENCRYPT 去保护她的消息。接着，她将加密的消息交给信使，并由信使转交给 Bob。Bob 收到加密的消息后，使用与 Alice 相同的密钥和函数 DECRYPT 恢复出原始消息。具体过程如图 1.4 所示。
图 1.4　（1）Alice 使用函数 ENCRYPT 和密钥将消息转变成像噪声一样的随机数字序列；（2）她将加密的消息交给信使，信使无法获知真实消息；（3）Bob 一旦收到加密的消息，他就可以使用和 Alice 一样的密钥和 DECRYPT 函数恢复出原始内容
在该消息传递过程中，信使拥有的都是看起来随机的消息，这不会对他获得隐藏的消息提供任何有意义的帮助。借助密码学技术，我们有效地将不安全的协议转变为安全协议。新协议使得 Alice 可以在没有任何人（除 Bob 外）知道消息内容的情况下向 Bob 传递一封机密信件。
在密码学中，使一个协议变得安全的常见做法就是：使用密钥将消息转变成噪声，使经过变换后的消息与随机数字序列无法区分开来。在接下来的章节中，我们将通过学习更多的密码算法来了解这个过程。
顺便说一句，对称加密是对称密码（Symmetric Cryptography）或密钥密码（Secret Key Cryptography）的一部分。此类密码学原语的不同函数往往使用相同的密钥。在后面的章节中，我们还会看到密钥有时不止一个。
++1.3　Kerckhoff 原则：只有密钥保密
设计一个密码算法（就像我们前面提到的对称加密原语）是一件简单的事情，但是设计一个安全的密码算法并非易事。虽然本书很少涉及构造这样的密码原语，但是本书会教大家判别一个密码算法优劣的方法。这做起来可能有点困难，因为对于一个给定的任务，我们可能有许多密码算法可以选择。不过，我们可以从密码学历史和密码学社区吸取他人的经验教训，并从中得到一些启示。通过回顾历史，我们可以了解到如何将一个密码算法变成安全可信的算法。
数百年后，依靠信件传递消息的 Alice 和 Bob 已经成为历史，纸质信件不再是我们的主要交流方式，取而代之的是更好、更实用的通信技术。如今，我们可以使用功能强大的计算机和互联网。当然，这意味着我们以前面临的恶意信使也变得更加强大。恶意信使无处不在：它可以是咖啡店里的 Wi-Fi 发射器，也可以是组成互联网并转发信息的服务器，还可以是运行我们算法的计算机。我们的敌手（恶意信使）现在也有能力观察到更多的信息，例如向网站发出的每一个请求都可能通过错误的线路传递，并在几纳秒内被更改或复制，而这一切可能不会有人察觉到。
回顾历史，我们可以清晰地看到密码算法存在漏洞、被一些组织或独立研究人员破解、不能真正地保护消息和未实现设计者所声称功能的例子比比皆是。通过从这些错误中总结经验教训，慢慢地我们知道了设计良好密码算法的方法。
注意：
攻破一个密码算法的方法有很多种。对于加密算法，我们可以通过以下方法来攻击这个算法：将密钥泄露给攻击者、在没有密钥的情况下解密消息、仅仅通过观察加密的消息就可以知道消息本身等。任何对算法假设的削弱也可以认为算法被攻破。
密码学的发展经历了漫长的试错过程，而一个更成熟的观点也在这个过程中产生：为了对密码学原语的安全性获得足够的信心，每个密码原语必须由密码专家对其进行公开分析。若做不到这一点，密码原语的可靠性只能依赖于含糊不清的安全性说明，而历史证明了其效果不尽如人意。这就是密码学家（Cryptographer，密码原语设计者）长期以来需要密码分析者（Cryptanalyst，又称「密码原语分析者」）帮助他们分析所构造密码原语安全性的原因（见图 1.5）。因此，密码学家也常常是密码分析者，反之亦然。
图 1.5　密码分析者的主要工作就是帮助密码学家分析所构造密码学原语的安全性
我们以高级加密标准（Advanced Encryption Standard，AES）加密算法为例。AES 算法是一个由美国国家标准与技术研究院（National Institute of Standards and Technology，NIST）组织的国际竞赛的产物。
注意：
NIST 是一个美国的标准和指南制定机构，其提出的标准主要供美国政府相关职能部门、其他公共和私人组织使用。NIST 对许多像 AES 算法这样应用广泛的密码原语进行了标准化。
AES 加密算法竞赛持续了数年之久，其间有许多来自世界各地的密码分析者参与尝试攻击各种各样的候选算法。历经数年的公开分析，人们对候选算法产生了足够的信心，最终将一个最具竞争力的算法提名为 AES 算法。如今，人们普遍认为 AES 算法是一个可靠、应用广泛的加密算法。例如，我们每天浏览网页就会用这个算法加密。
以公开方式构造密码算法标准的思路与 Kerckhoff 原则有关，该原则可以理解为：依靠保密算法来实现安全是不明智的，因为敌手很容易知道我们所使用的密码算法。因此，我们会选择公开密码算法。
如果 Alice 和 Bob 的敌手知道他们加密信息的算法，那么他们的加密算法还怎么保证安全呢？答案是密钥。协议的安全依赖密钥，而与算法本身是否保密无关。无论是我们将要学习的密码算法，还是在现实世界中使用的密码算法，我们通常都可以自由地进行研究和使用，这是本书涉及的密码算法的共性。只有作为这些算法输入的密钥才需要保密。就像吉恩·罗伯特·杜卡莱特（Jean Robert du Carlet）所说：「即使对大师来说，艺术也是一个秘密。」在 1.4 节中，我们将讨论一种完全不同的密码原语。现在，让我们用图 1.6 来汇总目前已学到的内容。
图 1.6　AES 是一个对称加密算法实例，对称加密算法是对称密码体系中的一类算法
++1.4　非对称加密：两个密钥优于一个密钥
在前面关于对称加密的讨论中，我们曾提到：Alice 和 Bob 在安全传递信件前需要见面，以确定他们将要使用的对称加密密钥。这是一个合理的要求，许多协议实际上都有这样的前提要求。然而，这样的要求在有许多参与者的协议中很快变得不那么实用：在安全连接到谷歌、Facebook、亚马逊和其他数十亿网站之前，网络浏览器是否也要满足这样的要求（即在连接前，浏览器之间要相互确定使用的对称加密密钥）？
这也称为密钥分发问题，在相当长的一段时间内该问题都未被解决，直到 20 世纪 70 年代末密码学家发现了另一类称为非对称密码（Asymmetric Cryptography）或公钥密码（Public Key Cryptography）的算法，密钥分发问题才得以解决。在非对称密码中，不同的函数（ENCRYPT 和 DECRYPT）使用不同的密钥（对称密码仅使用单个密钥）。为了说明公钥密码如何帮助人们建立信任，我将在本节介绍一些非对称密码原语。注意，这些原语只是本书内容的概览，在后续章节中我们会更详细地讨论这些密码原语。1.4.1　密钥交换
我们学习的第一个非对称密码原语是密钥交换（Secret Key Exchange）。DH 密钥交换算法是密码学家提出的第一个公钥密码算法，该算法以其提出者（Diffie 和 Hellman）的名字的首字母命名。DH 密钥交换算法的主要目的是为通信双方生成一个共享的秘密。这个双方共享的秘密可以用于不同的目的，例如作为对称加密原语的密钥。
在第 5 章中，我将详细解释 DH 密钥交换的工作原理。在本小节我们使用一个简单的类比来解释密钥交换。与大多数密码算法一样，在密钥交换算法执行前，参与者也必须获得一组公共参数。在类比说明中，我们用正方形 ■ 表示 Alice 和 Bob 协商好的公共参数（公共形状）。接下来，他们各自找到一个秘密地点，并随机选择一个形状。假设 Alice 选择的形状是三角形 ▲，而 Bob 选择的是星形 ★，同时他们会不惜一切代价地保密自己所选的形状。这些随机选择的形状就是他们各自的私钥（Private Key），如图 1.7 所示。
图 1.7　在 DH 密钥协商的第一步，双方生成私钥。在类比说明中，Alice 的私钥是三角形，Bob 的私钥是星形
当 Alice 和 Bob 选择完私钥后，他们就各自将他们随机选择的形状与他们起初协商的公共形状（正方形）结合起来。这些组合会产生唯一的新形状，每个新形状表示一个公钥（Public Key）。公钥属于公开信息，因此 Alice 和 Bob 可以相互交换他们的公钥。该过程说明如图 1.8 所示。
现在我们来思考这个算法为什么属于公钥密码算法。这是因为此类密码算法的密钥由一个公钥和一个私钥组成。DH 密钥交换算法的最后一步相当简单，即 Alice 和 Bob 分别将对方的公钥和自己的私钥结合在一起。最终，双方得到完全相同的结果（形状）。在所给的类比示例中，由正方形、星形和三角形组合在一起产生的形状如图 1.9 所示。
图 1.8　在 DH 密钥协商的第二步，双方交换公钥。双方通过将公共形状和私钥结合在一起来生成公钥
图 1.9　在 DH 密钥协商的最后一步：双方生成共享密钥。为了生成这个密钥，双方都将对方的公钥和自己的私钥结合在一起，而且仅仅通过两个公钥无法生成共享密钥
之后，协议的参与者可以使用这个共享密钥。本书也包含许多共享密钥使用场景的例子。例如，Alice 和 Bob 可以将共享密钥当作对称加密算法的密钥，进而使用这个对称加密原语去加密消息。DH 密钥交换的整个过程概括如下：
（1）Alice 和 Bob 交换掩盖了他们各自私钥的公钥；
（2）双方均使用对方的公钥和己方的私钥计算出共享密钥；
（3）敌手通过观察公钥不能获得私钥的任何信息，更不能计算出共享密钥。
注意：
在所给示例中，敌手很容易绕过最后一个问题。因为在不知道私钥的情况下，我们可以将公钥结合在一起生成共享密钥。幸运的是，这只是类比示例本身的局限性，而且并不影响我们理解密钥交换的内部原理。
实际上，DH 密钥交换是非常不安全的。你能花上几秒找出其不安全的原因吗？
这是因为 Alice 接收任何来自 Bob 的公钥，所以我可以拦截 Bob 发向 Alice 的公钥，并用我的公钥替换掉 Bob 的公钥，这样我就可以冒充 Bob（反之，我也可以向 Bob 冒充 Alice）。这样的中间人（Man-in-the-Middle，MITM）攻击者方法可以成功地攻击该密钥交换协议。那么如何修复协议的这个漏洞呢？在第 2 章我们会看到，修复该协议有两种方法，即用另一个加密原语增强这个密钥交换协议，或者提前知道 Bob 的公钥。但这不就意味着我们又回到了原点，即如何在协议开始之前确定双方公钥？
先前我们提到，Alice 和 Bob 需要知道一个共同的密钥；现在，我们又要求，Alice 和 Bob 需要事先知道彼此的公钥。双方如何才能知道对方的公钥呢？这不就是一个先有鸡还是先有蛋的问题吗？是的，的确如此。正如我们将看到的一样，在实践中，公钥密码并不能解决信任问题，它只是简化了信任的建立难度（特别是参与者数量有很多时）。
现在，让我们用图 1.10 来汇总目前学到的内容。我们停止讨论该话题，转而继续学习 1.4.2 小节内容。在第 5 章中，我们会了解更多关于密钥交换的内容。
图 1.10　到目前为止，我们学到的密码算法分属两大类，即对称密码（包含对称加密）和 非对称密码（包含密钥交换）1.4.2　非对称加密
在 DH 密钥交换算法提出后不久，密码学家 Ron Rivest、Adi Shamir 和 Leonard Adleman 又提出了一个新的密码算法，该算法也以他们的名字命名，称为 RSA 算法。RSA 算法包含两类不同的密码学原语：公钥加密（或非对称加密）算法和（数字）签名算法。这两个密码算法属于非对称密码中两类不同的密码学原语。在本小节中，我们将解释这些原语的功能以及它们在密码协议里发挥的作用。对于非对称加密，其功能与我们前面讨论的对称加密算法类似：它通过加密消息来保证机密性。不过，对称加密中两个参与方使用相同的密钥加密和解密消息，但在非对称加密中加密和解密消息的方式则完全不同：
● 非对称加密有两个密钥，分别称为公钥和私钥；
● 任何人都可以使用公钥加密消息，但是只有私钥拥有者才可以解密消息。
现在，我们用另外一个简单的类比示例来解释非对称加密的使用方法。我们再次从我们的老朋友 Alice 谈起，假设她持有私钥及其对应的公钥。我们把她的公钥想象成一个打开的盒子，它向公众敞开，任何人均可使用它，如图 1.11 所示。
图 1.11　为了使用非对称加密，Alice 首先公开她的公钥（这里用打开的盒子来表示）。任何人都可以使用这个公钥加密向她发送的消息。Alice 可以使用私钥解密收到的加密消息
任何人都可以使用 Alice 的公钥加密发向她的消息。在类比说明中，我们将加密消息想象成把消息放到打开的盒子里并关上它。一旦盒子关上，除了 Alice，任何人都没法打开放有消息的盒子。这个盒子有效地保证了消息的机密性，避免第三方获得消息本身。Alice 收到关闭的盒子（加密的消息）后，她可以用只有自己知道的私钥打开盒子（解密消息），获得消息，如图 1.12 所示。
图 1.12　非对称加密：（1）任何人都可以用 Alice 的公钥加密发给她的消息；（2）接收到加密的消息后； （3）她可以用对应的私钥解密，获得消息本身，第三方没法直接观察到发给 Alice 的消息
我们用图 1.13 总结了到目前为止学到的密码学原语。距离实用密码学之旅结束，我们需要学习的密码学原语只差一个！
图 1.13　到目前为止，我们学到的密码算法分属两大类，即对称密码（包含对称加密）和 非对称密码（包含密钥交换和非对称加密）1.4.3　数字签名：与手写签名作用一样
在 1.4.2 小节，我们了解了由 RSA 算法衍生出的非对称加密算法。同时提到，RSA 算法还能实现数字签名。数字签名原语能够有效地帮助 Alice 和 Bob 建立起信任，它的作用与手写签名十分类似。例如，当租赁公寓时，我们需要在租住合同上签字。
我们可能会产生这样的疑问：如果他们伪造我的签名怎么办？确实，手写签名在现实世界中并不能提供足够的安全性。密码上的签名也可能伪造，但是密码签名还会提供一个带有签名者姓名的密码证书。这能保证密码签名不可伪造，进而让别人很容易验证签名。与在支票上写的古老签名相比，密码签名更加有用！
在图 1.14 中，我们想象这样一个场景：Alice 想向 David 证明她信任 Bob。这是一个在多方环境中建立信任以及非对称密码技术使用场景的典型例子。Alice 通过在一张写有「Alice 信任 Bob」的纸上签名来表明立场，并告诉 David：Bob 是可以信任的。如果 David 信任 Alice 和她的签名算法，那么他也可以选择信任 Bob。
具体来说，就是 Alice 用她的 RSA 签名算法以及私钥对消息「Alice 信任 Bob」签名。这会产生一个类似随机噪声的签名，如图 1.15 所示。
图 1.14　David 信任 Alice。如果 Alice 信任 Bob，那么 David 也可以信任 Bob 吗
图 1.15　Alice 用她的私钥生成消息的签名
任何人都可以通过以下信息验证这个签名：
（1）Alice 公钥；
（2）待签消息；
（3）消息的签名。
验证结果只能是真（签名有效）或者假（签名无效），如图 1.16 所示。
图 1.16　为了验证 Alice 的签名，验证者还需要待签消息本身和 Alice 的公钥。验证结果只能是签名有效或者无效
到现在为止，我们已经学了 3 个不同的非对称密码原语：
（1）DH 密钥交换；
（2）非对称加密；
（3）RSA 数字签名。
这是 3 个非常著名且应用广泛的非对称密码算法。这些算法对于解决现实世界的安全问题所发挥的作用可能不会十分明显，但是这些算法确实每时每刻都在保护着我们所触及的各类应用。现在，让我们还用图来总结到目前为止我们学到的所有密码算法，如图 1.17 所示。
图 1.17　到目前为止，我们学过的对称密码算法和非对称密码算法
++1.5　密码算法分类和抽象化
我们将密码算法分为两大类。
● 对称密码（密钥密码）——算法只有一个密钥。如果多个参与者都知道该密钥，该密钥也称为共享密钥。
● 非对称密码（公钥密码）——参与者对密钥的可见性是非对称的。例如，一些参与者仅知道公钥，而另一些参与者同时知道公钥和私钥。
虽然对称密码和非对称密码并不是密码学中仅有的两类原语，但是由于我们很难对密码学的其他的子类进行划分，所以本书的大部分篇幅都是关于对称和非对称密码原语的。当今广泛应用的密码算法都包含在这两类原语中。另一种划分密码学原语的方式如下。
● 基于数学理论构造——这种密码算法的构造都建立在诸如因子分解之类的数学困难问题上。基于 RSA 算法的数字签名和非对称加密就属于这种构造。
● 基于启发式构造——这种算法的构造依赖于密码分析者的观察和统计分析。AES 算法就是这种构造的典型案例。
这种分类方式还考虑到算法效率因素，基于数学理论构造通常比基于启发式构造的密码算法要慢得多。我们可以得出这样的结论：对称密码大多数都是基于启发式构造的，而非对称密码主要是基于数学理论构造的。
我们很难严格地对密码学涉及的所有算法进行准确分类。事实上，每本书或每门课程对密码学定义和分类都有所不同。其实，这些定义和分类对我们来说并不重要，因为我们只会将这些密码学原语看作独特且具有各自的安全声明的工具。反过来，我们可以把这些工具当作构造安全协议的基础原语。对于实现协议安全，了解这些工具的工作原理以及提供的安全声明才是重中之重。出于这种考虑，本书的第一部分主要介绍常用的密码原语及其安全属性。
本书中的许多概念在初次使用时可能比较难懂。但与学习和理解其他知识一样，对这些概念了解得越多，在具体语境中见到的次数越多，我们就越能把它们抽象出来，理解起来也就愈加自然。本书的作用就是帮助读者建立起密码算法构造的抽象思维模型，理解把各类密码算法组合在一起形成安全协议的方法。本书会反复提到各类密码原语构造的接口，给出它们在现实世界的实际使用示例。
密码学以前的定义很简单，其原理类似于 Alice 和 Bob 想要交换秘密信息。当然，现在密码学的定义已经有了变化。当今，密码学围绕着新的发现、突破和实际需求演变成一门非常复杂的学科。归根结底，密码学的真正目的在于增强协议安全性，使协议在敌手存在的情况下仍能安全运行。
为了准确地理解密码学使协议变得安全的原理，厘清协议所要达到的一系列安全目标至关重要。本书涉及的密码原语至少满足下面性质中的一条。
● 机密性——掩藏和保护一些不想让别人看到的消息。例如，加密就可以掩盖传输中的消息。
● 认证性——确定通信另一方的身份。例如，认证技术可以让我们确信接收到的消息确实是由 Alice 发送来的。
当然，这里只是对密码学所能提供的算法功能进行了简化。在大多数情况下，每个密码原语的安全定义中都包含对算法功能的详细说明。密码原语的使用方式不同，协议产生的安全属性也会不同。
在本书中，我们将会学习一些新的密码原语，同时还会学习将它们组合起来实现满足机密性或认证性等安全属性的方法。请认识到这样一个事实：密码学是一门在敌手存在的环境下为协议提供安全保护的技术。虽然本书对「敌手」还没给出明确的定义，但是我们可以把企图破坏协议的参与者、观察者、中间人都当作敌手。这些角色反映了现实生活中敌手可能的身份。毕竟，密码学是一个实用的领域，它最终对抗的坏人是有血有肉的。
++1.6　理论密码学 vs.实用密码学
1993 年，Bruce Schneier 出版了《应用密码学》（Applied Cryptography）一书，该书旨在帮助应用程序开发者和软件工程师构建密码学应用。2012 年前后，Kenny Paterson 和 Nigel Smart 发起了一个名为「Real World Crypto」的年度会议，该密码学会议仍面向程序开发者和软件工程师。那么，应用密码学和实用密码学指的是什么？密码学难道不止一种吗？
要回答这些问题，我们还须从理论密码学（密码设计者和密码分析者所研究的密码学）的定义开始谈起。理论密码学研究者大多来自学术界和高校，但有少部分人可能来自工业界和政府特定部门。这些研究者的研究领域涉及密码学的各个方面，他们通过在期刊和会议上发表论文和演讲的形式向本领域的同行们分享最新研究成果。然而，并非每个研究者所做的研究都能在实际环境下应用。通常，这些研究者也不会对所提概念进行实证或进行代码实现。世界上甚至也不存在足以运行这些研究的计算机，所以这样的研究通常对现实应用没有多大意义。话虽如此，理论密码学有时也会走向实用密码学这一边，进而变得更有实用价值。
与理论密码学相对立的另一边是应用密码学（Applied Cryptography）或实用密码学（Real-world Cryptography）。实用密码学（应用密码学）是保证现实应用安全的基础。人们在现实生活中几乎感受不到实用密码学的存在，也无法直接看到它的具体应用。但是，当在互联网上登录银行账户，或向好友发送消息时，实用密码学技术就开始发挥作用了。实用密码学无处不在，不幸的是，不断观察和尝试破坏系统的攻击者也无处不在。实用密码学领域的工作者大多来自工业界，但他们有时也需要学术界的研究者帮助他们审查算法和设计的协议。实用密码学的研究结果也会通过会议、博客、帖子和开源软件等共享出来。
通常，实用密码学非常关心一些现实需求：算法提供的确切安全级别是多少？算法的运行时间是多长？密码原语要求的输入和输出有多大？我们可能已经猜到，本书的主题是实用密码学。虽然理论密码学并非本书主题，但在最后几章中我们会了解一些密码学家的前沿研究。等着吧，实用密码学未来的发展会让我们感到吃惊的。
现在，我们可能会有疑问：开发人员和工程师在实际应用中怎样选择和使用密码原语？
++1.7　从理论到实践：选择独特冒险
在密码学领域金字塔上面的是提出并解决数学难题的密码分析师，在金字塔下面的是希望加密某些数据的软件工程师。
——Thai Duong （“So you want to roll your own crypto?”，2020）
在研究和使用密码学的这些年里，我从未见过以单一模式在实际应用程序中使用密码原语的例子。现实情况是，密码学的使用方式相当混乱。在某一理论原语被采用前，会有很多的密码学研究者对其进行研究和分析，最终将其变成更实用、更安全的密码学原语。我该怎么解释这些呢？
听说过Choose Your Own Adventure一书吗？这是一个相对老旧的故事集，我们必须选择逐步完成故事中的任务。原则很简单，先按顺序阅读，然后通过书中提供的一些选项让我们决定接下来选择阅读哪一部分。每个选项都与一个不同的节号相关联，我们可以直接跳到所选节号的内容。因此，我也按照这种方式安排本书内容。从下一段开始，我们可以按照本书所给顺序去读本书。
一切从这里开始。你是谁？你是密码学家 Alice 吗？还是在私企工作而且有问题亟待解决的 David 呢？或者你是在特殊部门工作，专门从事密码学研究的 Eve？
● 如果你是 Alice，请跳到步骤 1。
● 如果你是 David，请跳到步骤 2。
● 如果你是 Eve，请跳到步骤 3。
步骤 1：研究人员必须进行研究。你是一位在大学工作的研究员，或者是一名任职于私人公司或非营利组织的研究者，或者你就职于 NIST 或 NSA 等美国政府研究机构。因此，你的研究资助可能来自不同的机构或组织，这可能会激励你研究不同的东西。
● 你会发明一个新的密码原语，请跳到步骤 4。
● 你会提出一个新的构造，请跳到步骤 5。
● 你打算参与一场密码竞赛，请跳到步骤 6。
步骤 2：工业有需求。工作任务就是提出新的行业标准。例如，Wi-Fi 联盟就是一个由专注于 Wi-Fi 协议的公司资助的非营利组织，该组织旨在制定一套有关 Wi-Fi 协议的标准。另一个与标准工作有关的例子是，多家银行联合制定支付卡行业数据安全标准（The Payment Card Industry Data Security Standard，PCI-DSS），在处理信用卡号时，该标准会强制要求使用规定的算法和协议。
● 你决定去资助一些需要的研究，请跳到步骤 1。
● 你决定提出一些新的原语或协议，请跳到步骤 5。
● 你打算发起一场密码算法竞赛，请跳到步骤 6。
步骤 3：政府有需求。你为政府效力，需要设计一些新的密码算法。例如，NIST 的任务就是发布联邦信息处理标准（The Federal Information Processing Standard，FIPS），该标准规定了处理政府事务的公司可以使用哪些密码算法。虽然这些标准中大多是成功的案例，人们对政府机构推行的标准也抱有高度的信任，但是关于这些标准的失败之处也值得一谈。
2013 年，在爱德华·斯诺登（Edward Snowden）披露了一些美国政府的丑闻之后，人们发现美国国家安全局（NSA）故意将一个藏有后门的算法纳入其推行的标准中（见 Bernstein 等人的文章「Dual EC: A Standardized Back Door」），这个后门算法允许 NSA（只有 NSA）推测密钥。这些后门如同「魔法口令」一样，使美国政府（据说只有美国政府）可以破解加密的消息。之后，密码社区不再信任美国政府机构推出的标准和建议。在 2019 年，人们发现俄罗斯标准机构 GOST 也出现类似的情况。
密码学家一直怀疑 GOST 在 2006 年发布的一项 NIST 通过的标准中植入了漏洞，后来这项标准被由拥有 163 个成员方的国际标准化组织（International Organization for Standardization）采纳。而美国国家安全局的机密备忘录似乎也能证实：两位微软密码学家在 2007 年发现该标准中的致命弱点是由 GOST 机构设计的。值得注意的是，正是 NSA 编写了该标准，并积极在国际组织上推行该标准，并私下称其为「技巧上的挑战」。
——《纽约时报》（“N.S.A. Able to Foil Basic Safeguards of Privacy on Web”，2013）
● 你要资助一些研究，请跳到步骤 1。
● 你要组织一场公开竞赛，请跳到步骤 6。
● 你打算将正在使用的原语或协议标准化，请跳到步骤 7。
步骤 4：提出新概念。作为一名研究人员，总是设法做到一些不可能完成的事情；确实，尽管可用的加密原语已经有很多，但密码学家每年仍会提出一些新的原语。其中，有些概念是不可能实现的，而有些概念最终可以实现。也许，你已有实际的构造，并将其作为所提原语的一部分，或者选择等待，看看是否有人可以想出一些新的原语。
● 你提出的原语已经实现，请跳到步骤 5。
● 你提出的原语最终不可以实现，请跳到开头部分。
步骤 5：一个新的原语或协议被提出。密码学家通过提出一种新的算法来实例化一个概念。例如，AES 是一个加密方案（AES 最初由 Vincent Rijmen 和 Joan Daemen 提出，他们用其名字的缩写 Rijndael 来命名这个算法，又称 Rijndael 加密法）。下一步该怎么做呢？
● 某个人以你的构造为基础提出新的构造，请跳到步骤 5。
● 你参加了一个公开的比赛，并且赢得这场赛事！请跳到步骤 6。
● 你所做的工作受到大肆宣传，并且即将成为标准，请跳到步骤 7。
● 你决定将你的构造申请成专利，请跳到步骤 8。
● 你或其他人认为你构造的原语非常有趣，并决定将该构造实现出来，请跳到步骤 9。
步骤 6：算法在竞赛中获胜。密码学家最喜欢的竞技就是一场公开的比赛！例如，AES 就是一项由世界各地密码学研究者都可自由参加的竞赛。整个竞赛经过数十次的提交和几轮密码分析者的分析（这可能需要几年时间），候选算法名单中的算法逐渐减少，直至剩下一个算法，便将该算法作为标准。
● 你很幸运，经过多年的竞争，你的新构造最终赢得比赛！请跳到步骤 7。
● 你不够走运，输掉了比赛，请回到开头。
步骤 7：标准化算法或协议。标准通常由政府或标准化机构发布。标准化的目的是最大限度地提高互操作性。例如，NIST 会定期发布一些密码标准。著名的密码学标准化机构当属国际互联网工程任务组（Internet Engineering Task Force，IETF），本书中涉及的许多互联网标准（如 TCP、UDP、TLS 等）都出自该机构。IETF 中的标准被称为征求意见（Request For Comment，RFC），并且几乎任何想要编写标准的人都可以编写。
为了强调不通过投票表决问题，我们还采用了「决议」的传统：例如，在面对面的会议中，工作组主席为了让大家获得「决策权」，有时会要求参会者就一个特定的问题（「赞成」或「反对」）进行交流，而不是举手表决。
——RFC 7282（“On Consensus and Humming in the IETF”，2014）
有时，某个公司会直接发布一个标准。例如，RSA Security LLC（由 RSA 算法的创建者出资）为了让本公司使用的算法和技术合法化，曾发布了 15 个称为公钥加密标准（Public Key Cryptography Standards，PKCS）的技术文件。如今，这种情况非常少见。现在，许多公司都是通过 IETF 将它们的协议或算法标准化为 RFC 文档，而不是去自定义一些新的标准化文档。
● 你提出的算法或协议得到实现，请跳到步骤 9。
● 没有人关心你发布的标准，请回到开头。
步骤 8：专利到期。通常，密码算法被申请了专利就意味着没有人会使用该算法。然而，一旦专利到期，人们会对这个算法重新产生兴趣，这并不是什么罕见之事。最典型的例子可能是 Schnorr 签名，该算法是一个备受欢迎的签名算法，这种情形持续到 1989 年 Schnorr 为该签名算法申请专利。这导致 NIST 只能将一个较差的签名算法作为标准，称为数字签名算法（Digital Signature Algorithm，DSA），该算法在当时成为首选签名算法，但如今很少使用。Schnorr 签名的专利于 2008 年到期，此后该算法再次流行起来。
● 时间过了很久，你提出的算法仍无人过问，请回到开头。
● 你的构造引发了一系列新的构造，这些新的构造都以你先前的构造为基础，请跳到步骤 5。
● 现在很多人想使用你的构造，但只有你的构造成为标准后他们才肯使用，请跳到步骤 7。
● 一些开发者正在使用你设计的算法，请跳到步骤 10。
步骤 9：实现一个新的构造或协议。实现者不仅要完全搞懂一篇论文或一项标准（尽管标准的撰写本来就应该是面向实现者的），而且必须使实现的算法易于使用，这是一项艰巨的任务。另外，使用者还可能会以一种错误的方式使用密码算法，因此做到正确使用密码算法也并非易事。
● 有人认为标准本身应该包含相应的实现，不提供具体实现的标准不够完备，请跳到步骤 7。
● 你编写的密码程序库得到极力推广，请跳到步骤 10。
步骤 10：作为开发人员在应用程序中使用密码协议或原语。你的密码程序库可以轻松满足开发人员的需要！
● 某个原语可以解决你的需求，但它没有被标准化。情况有点不好，请跳到步骤 7。
● 我希望用我熟悉的编程语言实现这个原语，请跳到步骤 9。
● 我以错误的方式使用这个密码库，或者使用的构造已被攻破，游戏结束。
让一个密码原语变得在现实世界可用的方法有很多。最好的方法应该是采用经过多年的安全分析、对算法实现者友好的标准，以及性能良好的密码程序库。最糟糕的方法是使用不安全的算法和不友好的实现。一个密码原语变得实用的最佳路线如图 1.18 所示。
图 1.18　一个密码算法的理想生命周期始于密码学家实例化了某个概念。例如，AES 是对称加密概念的一个实例（对称加密算法还有很多）。一个新的密码原语构造可以这样被标准化：每个人都同意以某种方式来实现它以最大限度地提高互操作性。然后，用不同的语言实现该标准，使标准化的密码算法得以广泛应用
++1.8　警示之言
无论是那些业余的密码学爱好者，还是那些顶尖的密码学家，他们都能设计出一种自己无法破解的密码算法。
——Bruce Schneier (“Memo to the Amateur Cipher Designer”, 1998)
在这里我们必须知道这样一个事实：密码学是一门很难完全掌握的技术。读完本书后就去尝试设计复杂的密码协议是一种不明智的做法。在这段密码学之旅中，本书的目的是给大家带来一些启发，告诉大家密码学能够做什么，让大家理解一些密码学技术的原理，但无法让大家成为密码学大师。
本书不是密码学圣经。本书的最后会告诉大家一条重要的经验——不要独自进行密码学上的冒险。为了打败可以「杀人」的「恶龙」，我们需要一些持续不断的支持。换句话来说，密码学是复杂的，本书的主要作用就是不让我们滥用所学的密码学知识。对于设计复杂的密码学系统，唯有在密码学领域深耕多年的专家才能胜任。本书主要让大家明白哪些场合该用密码技术，或者什么样的使用方式应该受到怀疑，使用哪些密码原语和协议才能解决大家正面临的问题，以及所有这些密码算法的底层原理。如果已经了解了这些警示之言，那就开始学习下一章内容吧！
++1.9　本章小结
● 协议是一个参与者通过逐步交互实现机密信息交换的过程。
● 密码学是一门考虑在敌手存在的条件下使协议变得安全的学科。其中的实现过程经常需要密钥。
● 一个密码学原语指的是一类密码算法。例如，对称加密是一个密码原语，而 AES 是一个具体的对称加密算法。
● 对不同的密码学原语可按多种方式分类，其中一种方式是将它们分为两类：对称密码和非对称密码。对称密码只有一个密钥（如对称加密），而非对称密码有多个不同的密钥（如密钥交换、非对称加密和数字签名）。
● 按照密码算法的性质很难对其进行分类，但这些算法通常主要提供两个基本功能：认证性和机密性。认证性是指验证某些消息或人的真实性，而机密性是指数据或身份的隐私性。
● 实用密码学在实际的技术应用中无处不在，而理论密码学在实践中往往用处不大。
● 本书中包含的大多数密码学原语都是经过标准化才确定下来的。
● 密码学本身非常复杂，在实现和使用密码学原语时需要多加小心。